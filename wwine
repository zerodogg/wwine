#!/usr/bin/ruby
# wwine
# Copyright (C) Eskild Hustvedt 2009, 2010, 2011, 2012
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Command-line parsing
require 'getoptlong'
# To read info for --debuginfo
require 'open3'
# Application version
$version = '0.2.2'
# The wine flavour to use
$wine = nil
# The bottle to use
$bottle = nil
# Verbose mode (true/false)
$verbose = false
# CX path
$cxPath = nil
# Path to write wrapper to
$wrapperPath = nil
# Directory to cd to in a wrapper
$wrapperCwd = nil
# File to load wwine data from
$wwineDataFrom = nil
# true if we're in --env mode
$envMode = false
# true if we're in --tricks mode
$tricksMode = false

# Purpose: Attempt to kill all running wine processes
def killWine (dryRun = false, signal = 15)
	# Open a pipe to ps to read processes
	wines = IO.popen('ps uxw')
	# True if we have killed something
	killed = false
	# The name of the signal being sent
	sigName = 'SIGTERM'
	# Get an integer version of signal parameter
	begin
		signal = Integer(signal)
	rescue
		signal = nil
	end
	# If the signal parameter is invalid, error out
	if signal == nil
		signal = 15
	elsif signal > 15 || signal < 0
		puts('Argument to --kill must be an integer between 0-15 (or none at all)')
		exit(1)
	end
	# Map of number => name
	sigNames = { 9 => 'SIGKILL', 15 => 'SIGTERM', 2 => 'SIGINT' }
	if sigNames[signal] != nil
		sigName = sigNames[signal]
	else
		sigName = 'signal '+signal
	end
	# Go through each line in the 'ps' output
	wines.each do |line|
		# True if we *require* /proc to be read for this process.
		# This is for cases where, judging by the process name we shouldn't
		# kill that process, but it's close enough to something we could kill
		# that we want to check if /proc can provide a more definitive answer.
		# (helps kill defunct processes)
		requireProc = false

		line.chomp!
		# Ignore the header
		if line =~ /USER\s*PID/
			next
		end
		pid = String.new(line)
		name = String.new(line)
		# Parse the PID
		pid.sub!(/^\S+\s*(\d+)\s+.*/,'\1')
		# Parse the name
		name.sub!(/^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+/,'')
		# If either of these are true some part of the parsing failed, and we
		# should thus simply skip this line
		if pid == name || pid == line || name == line
			next
		end
		# Ignore processes that are not wine-related
		if name =~ /(wine|windows|[A-Za-z]:\\|\.(exe|dll))/i
			# If wine is not a part of the process name, check if the
			# name either includes a *:\ (which most likely means it is a windows
			# path because it has already matched one of the above) or exe/dll.
			if name !~ /wine/i && (name !~ /[A-Za-z]:\\/ || name !~ /\.(exe|dll)/i)
				requireProc = true
			end
		else
			next
		end
		# At least on Linux kernels, /proc/ will include useful info, we use it to
		# check if the exe actually is wine

			# /exe test
		if File.readable?('/proc/'+pid+'/exe') and File.symlink?('/proc/'+pid+'/exe')
			linkValue = File.readlink('/proc/'+pid+'/exe')
			if File.readlink('/proc/'+pid+'/exe') !~ /\/[^\/]*wine[^\/]*$/i
				next
			end
			# /cmdline test (for when /exe isn't readable)
		elsif File.readable?('/proc/'+pid+'/cmdline')
			cmdline = IO.read('/proc/'+pid+'/cmdline')
			cmdline.sub!(/\0.*/,'');
			if cmdline !~ /\/[^\/]*wine[^\/]*$/i && cmdline !~ /^[A-Za-z]:\\[^\\]+\\/
				next
			end
		elsif requireProc
			next
		end
		# Clean up the name
		name.sub!(/\s*$/,'')
		# Send SIGTERM (or output information if in dryRun mode)
		if !dryRun
			puts 'Sending '+sigName+' to '+name+' (PID '+pid+')'
			begin
				Process.kill(signal,pid.to_i)
			rescue 
				puts('Error while attempting to send signal to '+pid+': '+$!)
			end
		else
			puts 'Would send '+sigName+' to '+name+' (PID '+pid+')'
		end
		killed = true
	end
	if ! killed
		puts 'No wine processes found.'
	end
end

# Purpose: Print formatted --help output
# Usage: printHelp('-shortoption', '--longoption', 'description');
#  Description will be reformatted to fit within a normal terminal
def printHelp (short,long,description)
	maxlen = 80
	optionlen = 20
	# Check if the short/long are LONGER than optionlen, if so, we need
	# to do some additional magic to take up only $maxlen.
	# The +1 here is because we always add a space between them, no matter what
	if (short.length + long.length + 1) > optionlen
		optionlen = short.length + long.length + 1;
	end

	generatedDesc = ''
	currdesc = ''

	description.split(/ /).each do |part|
		if(generatedDesc.length > 0)
			if (currdesc.length + part.length + 1 + 20) > maxlen
				generatedDesc.concat("\n")
				currdesc = ''
			else
				currdesc.concat(' ')
				generatedDesc.concat(' ')
			end
		end
		currdesc.concat(part)
		generatedDesc.concat(part)
	end
	if !(generatedDesc.length > 0)
		raise("Option mismatch")
	end
	generatedDesc.split(/\n/).each do |descr|
		printf("%-4s %-15s %s\n",short,long,descr)
		short = ''; long = ''
	end
end

# Purpose: Quote a string (or array of strings) for use in the shell
def shellQuote(target)
	if target.class == Array
		newTarget = []
		target.each do |subt|
			subt = shellQuote(subt)
			newTarget.push(subt)
		end
		return newTarget
	end

	fixedTarget = target.gsub('\\') { '\\\\' }
	fixedTarget.gsub!(/'/,"'\"'\"'")

	finalTarget = "'"
	finalTarget.concat(fixedTarget)
	finalTarget.concat("'");
	return finalTarget
end

# Purpose: Unquote a string generated by shellQuote
def unShellQuote(target)
	fixedTarget = target.gsub("\\'","'")
	fixedTarget.gsub!('\\\\') { '\\' }
	return fixedTarget
end

# Purpose: Unquote a full line of shellQuoted strings
def unquoteShellArray (source,targetarr)
	source.split(/ '/).each do |part|
		part.sub!(/'$/,'')
		part.sub!(/^'/,'')
		part.chomp!
		if part.match(/\S/)
			targetarr.push(unShellQuote(part))
		end
	end
	return targetarr
end

# Purpose: Write a wrapper script
def writeWrapper (targetFile, wwineCommand, otherCommand, cwd, wwineInfo, args, wineprefix = nil)
	# Open the file for writing
	begin
		file = File.open(targetFile,'w')
	rescue
		puts('Failed to open "'+targetFile+'" for writing: '+$!)
		exit(1)
	end

	file.puts('#!/bin/sh')
	file.puts('# Script autogenerated by wwine '+$version+' (http://random.zerodogg.org/wwine)')
	file.puts('# Licensed under the GNU General Public License version 3 or later')
	file.puts('#')
	file.puts('# You should have received a copy of the GNU General Public License')
	file.puts('# along with wwine. If not, see <http://www.gnu.org/licenses/>.')
	file.puts('#')
	file.puts('# -- Begin wwine metadata --')
	file.puts('# wwineInfo: v2')
	file.puts('# wwineDir: '+wwineInfo[0])
	file.puts('# wwineWine: '+wwineInfo[1])
	file.puts('# wwineBottle: '+wwineInfo[2])
	file.puts('# wwineCxinstalldir: '+wwineInfo[3])
	# wwineCmd isn't used in v2, but v1 outputs an invalid message if it
	# doesn't exist. wwineCmd (unnumbered) will be dropped in a later version.
	file.puts('# wwineCmd: nil')

	subN = 0
	args.each do |sub|
		file.puts("# wwineCmd["+subN.to_s+"]: "+sub)
		subN += 1
	end

	file.puts('# -- End wwine metadata  --')
	file.puts('')
	file.puts("cd "+shellQuote(cwd)+" || exit 1")
	file.puts('wwine='+shellQuote(File.expand_path($0)))
	file.puts('if [ ! -x "$wwine" ]; then')
	file.puts("\t"+'wwine="`which wwine 2> /dev/null`"')
	file.puts('fi')
	file.puts('if [ "x$wwine" != "x" ]; then')
	file.puts("\t"+'exec "$wwine" '+shellQuote(wwineCommand).join(" ")+' "$@"')
	file.puts('else')
	# Add wineprefix if needed. This is used when --wine is wine because wine
	# has no support for specifying a bottle on the command-line.
	if wineprefix != nil
		wineprefix.sub!(/'/,'\\')
		file.puts("\t"+'export WINEPREFIX='+shellQuote(wineprefix))
		file.puts("\t"+"export WINEDEBUG='-all'");
	end
	file.puts("\t"+"exec "+shellQuote(otherCommand).join(" ")+' "$@"')
	file.puts('fi')
	file.puts('echo "Launch script failed. No wwine found and wine command failed to exec."')
	file.puts('exit 1')

	file.chmod(0755)
	file.close

	puts('Wrote wrapper script to '+targetFile)
end

# Purpose: Generate a wwine command and wwineInfo array
def generateWwineCmd (wine,bottle,wineCommand,type = nil)
	wwineCmd = []
	wwineInfo = ['nil','nil','nil','nil']

	# Generate a wwine command-line
	if $verbose
		wwineCmd.push('--verbose')
	end
	if $cxPath
		wwineCmd.push('--cxinstalldir',$cxPath)
		wwineInfo[3] = $cxPath
	end
	if wine
		wwineCmd.push('--wine',wine)
		wwineInfo[1] = wine
	end
	if bottle
		wwineCmd.push('--bottle',bottle)
		wwineInfo[2] = bottle;
	end
	return wwineCmd, wwineInfo
end

# Purpose: Prepare to generate a wrapper script
def generateWrapper (wine,bottle,targetFile,wineCommand,args,type = nil)

	if File.exists?(targetFile)
		puts(targetFile+': already exists. Bailing out')
		puts('Remove the target file first, then try again')
		exit(1)
	end

	wwineCmd, wwineInfo = generateWwineCmd(wine,bottle,wineCommand,type)

	# Append -- if it isn't already
	if ! args.join(' ').match(/ -- /)
		wwineCmd.push('--')
	end

	wwineCmd.concat(args)

	if $wrapperCwd == nil
		$wrapperCwd = Dir.pwd
	end

	wwineInfo[0] = $wrapperCwd

	wineprefix = nil

	# For wine there is no --bottle definition in the wine command itself,
	# so we need to export a wineprefix in the launch script
	if type == 'wine'
		wineprefix = ENV['WINEPREFIX']
	end

	writeWrapper(targetFile ,wwineCmd, wineCommand, $wrapperCwd, wwineInfo, args, wineprefix)
end

# Purpose: Sets WINE and WINEPREFIX, and then either outputs them to STDOUT, or
# 		executes whatever native command was supplied (the logic that handles --env)
def setEnvAndExec (wine,bottle,cmd,args,type)
	wwineCmd, wwineInfo = generateWwineCmd(wine,nil,cmd,type)

	wwineCmd.push('--env-bottle')
	wwineCmd.push('--')
	wwineCmd.unshift(File.expand_path($0))

	if !bottle
		puts("--env requires a --bottle")
		exit(1)
	end

	if wine == 'wine' || File.exists?(wine)
		bottlePath = ENV['WINEPREFIX']
	elsif wine == 'cedega'
		bottlePath = ENV['HOME']+'/.cedega/'+bottle
	else
		bottlePath = getCXwithParams(wine,bottle,true,true)
	end

	ENV['WINEPREFIX'] = bottlePath
	ENV['WINE'] = wwineCmd.join(" ")
	if args.length > 0
		exec *args
	else
		puts("WINE="+shellQuote(ENV['WINE']))
		puts("WINEPREFIX="+shellQuote(ENV['WINEPREFIX']))
	end
	exit
end

# Purpose: Load wwine data from a wrapper script
def loadWwineDataFromFile (file,dryRun = false)
	begin
		if !File.exists?(file)
			puts file+': does not exist'
			exit(1)
		elsif ! File.readable?(file)
			puts file+': is not readable'
			exit(1)
		end

		# Don't output any info-messages when in --env mode
		if $envMode
			outFormat = ''
		else
			puts 'Loading settings from '+file+':'
			outFormat = '%-20s: %s'+"\n"
		end
		source = File.open(file)

		if $wrapperPath
			outMessage = ''
		else
			outMessage = 'Using '
		end

		info = Hash.new
		wwineInfo = ''
		wwineCmd = ''

		source.each do |line|
			if line.match(/^#\s+wwine/)
				key = line.sub(/^#\s+wwine(\S+):\s*(.+)$/,'\1').chomp
				value = line.sub(/^#\s+wwine(\S+):\s*(.+)$/,'\2').chomp
				info[key] = value
			end
		end

		if ! info['Info']
			puts "The wwine header in this file is broken or missing."
			puts "Unable to continue."
			exit(0)
		end
		if info['Info'] == 'v2'
			info = parseWwineDataV2(info);
		elsif info['Info'].match(/^v1/)
			info = parseWwineDataV1(info)
		else
			version = info['Info'].sub(/^(v\S+).+/,'\1').chomp
			puts "This version of wwine supports info format v1 and v2."
			puts "This file is version "+version
			puts "Unable to continue."
			exit(0)
		end

		if info['Cmd'].length < 1
			puts "The wwine header in this file is broken."
			puts "Unable to continue."
			exit(0)
		end

		# Get the directory
		if info['Dir'] != 'nil' && !$wrapperCwd && !$envMode
			if $wrapperPath
				switchMessage = '--wrapdir'
			else
				switchMessage = 'Switching to directory'
			end
			printf(outFormat,switchMessage,info['Dir'])
			if File.exists?(info['Dir'])
				if $wrapperPath
					$wrapperCwd = info['Dir']
				else
					Dir.chdir(info['Dir'])
				end
			else
				puts info['Dir']+': does not exist, giving up.'
				exit(0)
			end
		end

		# Get the --wine to use
		if $wine == nil && info['Wine'] != 'nil'
			$wine = info['Wine']
			printf(outFormat,outMessage+'--wine',$wine)
		end

		# Get the --bottle to use
		if $bottle == nil && info['Bottle'] != 'nil'
			$bottle = info['Bottle']
			printf(outFormat,outMessage+'--bottle',$bottle)
		end

		# Get the --cxinstalldir to use
		if $cxPath == nil && info['Cxinstalldir'] != 'nil'
			$cxPath = info['Cxinstalldir']
			printf(outFormat,outMessage+'--cxinstalldir',$cxPath)
		end

		# Set the command to run
		if ! dryRun && !$envMode
			if $wrapperPath
				out = 'Program command'
			else
				out = 'Will now run'
			end
			printf(outFormat,out,info['Cmd'].join(' '))
			ARGV.unshift(*info['Cmd'])
		end
	rescue => ex
		handleException(ex)
	end
end

# Parses wwine metadata version 1 (wwine 0.1.x)
def parseWwineDataV1 (rawData)
	data = []
	unquoteShellArray(rawData['Info'],data)
	info = Hash.new
	info['Dir'] = data[1]
	info['Wine'] = data[2]
	info['Bottle'] = data[3]
	info['Cxinstalldir'] = data[4]

	cmd = []

	unquoteShellArray(rawData['Cmd'],cmd)
	info['Cmd'] = cmd
	return info
end

# Parses wwine metadata version 2 (wwine 0.2+)
def parseWwineDataV2 (data)
	cmd = []
	currNo = 0
	while currNo < 999
		if data['Cmd['+currNo.to_s+']'] != nil
			cmd.push(data['Cmd['+currNo.to_s+']'])
		else
			break
		end
		currNo += 1
	end
	data['Cmd'] = cmd
	return data
end

# Purpose: Run a command, outputting info of it in verbose mode
def runcmd(cmd, type = 'exec')
	if(type == 'exec')
		vputs 'Executing: '+cmd.join(' ')
		exec *cmd
	else
		vputs 'Running: '+cmd.join(' ')
		return system(*cmd)
	end
end

# Purpose: Check for a file in path
def inPath(exec)
	ENV['PATH'].split(/:/).each do |part|
		if File.executable?(part+'/'+exec) and not File.directory?(part+'/'+exec)
			return true
		end
	end
	return false
end

# Purpose: Output a string if in verbose mode
def vputs (str)
	if $verbose
		puts(str)
	end
end

# Purpose: Print the help output
def Help ()
	puts "wwine "+$version
	puts ""
	puts "Usage: wwine (WWINE PARAMETERS) PROGRAM -- [PROGRAM ARGUMENTS]"
	puts ""
	printHelp('-h','--help','Display this help text')
	printHelp('-w','--wine','Select the wine to use: wine, crossover, cxgames, cedega, or a path to a wine bin. Default: wine')
	printHelp('-b','--bottle','Use the selected bottle (~/.wwinebottles/[NAME] for wine, CX bottle or cedega folder, depending on the --wine in use). The bottle will be created if it does not exist.')
	printHelp('','--env','Set the WINE and WINEPREFIX environment variables to match the parameters provided to wwine and optionally run a program with those variables set.')
	printHelp('-k','--kill','Attempt to kill all running wine processes')
	printHelp('','--drykill','Print what --kill would have done, but don\'t actually do anything')
	printHelp('-c','--cxinstalldir','Use the supplied path as the install path for CXoffice/CXgames (default: autodetect).')
	printHelp('','--wrap','Write a wrapper script of your current wwine command to the path supplied')
	printHelp('','--wrapdir','Use the supplied directory as the working directory for the script created by --wrap (default: current directory)')
	printHelp('-s','--from','Load parameters and program from the wrapper script supplied. Command-line arguments overrides settings from wrapper script.')
	printHelp('-v','--verbose','Enable verbose mode')
	printHelp('','--man','Show the wwine manpage')
end

# Purpose: Show the manpage
def showManPage ()
	if ! inPath('man')
		puts
		puts "You don't appear to have the 'man' program installed."
		puts "Please install it, then re-run wwine --man"
		exit(0)
	end
	mySelf = File.expand_path($0)
	while File.symlink?(mySelf)
		mySelf = File.readlink(mySelf)
	end
	sourceDir = '.'
	if mySelf != nil
		sourceDir = File.dirname(mySelf)
	end
	dirs = [sourceDir]
	if ENV['MANPATH']
		dirs.concat(ENV['MANPATH'].split(':'))
	end
	dirs.push('./')
	dirs.each do |dir|
		[ 'wwine.1','man1/wwine.1','man1/wwine.1.gz','man1/wwine.1.bz2','man1/wwine.1.lzma'].each do |manFile|
			if File.exists?(dir+'/'+manFile)
				exec('man',dir+'/'+manFile)
			end
		end
	end
	puts
	puts 'wwine failed to locate its manpage.'
	puts 'Run the following command to view it:'
	puts '\curl -s "http://github.com/zerodogg/wwine/raw/master/wwine.1" |  groff -T utf8 -man | \less'
end

# Purpose: Get wine version
def getWineVersion (source = 'wine', fromStderr = false, cmdOpt = '--version')
	wineVer = nil

	# Don't try to get it if we have no wine to run
	if inPath(source) || File.executable?(source)
		begin
			cmd = [ source,cmdOpt ]
			Open3.popen3(*cmd) { |stdin, stdout, stderr|
				# Fetch the line from either stderr or out
				if fromStderr
					wineVer = stderr.gets(nil)
				else
					wineVer = stdout.gets(nil)
				end
			}
			# Get the actual version number by stripping away any leading nondigit text
			wineVer.sub!(/^\D+/,'')
			wineVer.chomp!
		rescue
			wineVer = nil
		end
	end
	return wineVer
end

# Purpose: Get cedega version string
def getCedegaVersionString ()
	cedegaVer = nil

	if inPath('cedega')
		begin
			# We need the HOME variable
			if ENV.has_key?('HOME')
				# The cedega RC file
				rcFile = ENV['HOME']+'/.cedega/.cedegarc'
				# The cedega build number file
				uiBuildFile = ENV['HOME']+'/.cedega/.ui/BUILDNUMBER'
				# If we have the rc file, open it and fetch the current default
				# engine version from the 'default' setting. It is the closest we are
				# going to get to a current version number without jumping through a lot
				# of hoops.
				if File.exists?(rcFile)
					ind = File.open(rcFile)
					ind.each do |line|
						if line.match(/^default=/)
							line.sub!(/^default=/,'')
							line.chomp!
							cedegaVer = line
							break
						end
					end
				end
				# If we have a default ver, fetch the UI version as well, as we have to pass
				# through the UI, that number can be useful
				if cedegaVer != nil && File.exists?(uiBuildFile)
					ind = File.open(uiBuildFile)
					buildNo = ind.gets(nil)
					buildNo.chomp!
					if buildNo != nil
						cedegaVer.concat(' (UI build '+buildNo+')');
					end
				end
			end
		rescue
		end
		if cedegaVer == nil
			cedegaVer = 'present'
		end
	else
		cedegaVer = '(not present)'
	end

	return cedegaVer
end

# Purpose: Get cx* version
def getCXVersionsFrom (source,wantString = false)
	cxVer = nil
	cxwVer = nil
	if source != nil 
		begin
			# Store the binfile for use later
			binFile = source[0]
			# pop off the dummy command
			source.pop
			# Add version
			source.push('--version')
			source = source.join(' ')

			out = IO.popen(source)
			# The info we need is on line two
			cxVer = out.readline
			cxVer = out.readline
			# Get the actual version number by stripping away any leading nondigit text
			cxVer.sub!(/^\D+/,'')
			cxVer.chomp!

			cxwVer = getWineVersion(binFile.sub(/cxstart$/,'wineserver'),true,'-v')
		rescue
			cxwVer = nil
			cxVer = nil
		end
	end
	if wantString
		# If a string has been requested, generate one and return it
		if cxVer != nil
			if cxwVer != nil
				return cxVer+' (based on wine '+cxwVer+')'
			else
				return cxVer
			end
		else
			return '(not present)'
		end
	else
		return cxVer,cxwVer
	end
end

# Purpose: Print debugging info
def debugInfo ()
	outFormat = '%-20s: %s'+"\n"
	puts "wwine "+$version
	# Load a --from file if it is set
	if $wwineDataFrom
		loadWwineDataFromFile($wwineDataFrom,true)
	end
	# Fetch the md5sum of us. This will at least give a certain clue about the revision
	# of wwine used. Primarily useful for identifying older git clones in bug reports.
	begin
		if inPath('md5sum')
			outStr = nil
			out = IO.popen('md5sum '+File.expand_path($0))
			outStr = out.readline
			outStr.sub!(/\s+.*$/,'')
			outStr.chomp!
			printf(outFormat,'wwine md5sum',outStr)
		else
			printf(outFormat,'wwine md5sum','(md5sum command missing)')
		end
	rescue
		printf(outFormat,'wwine md5sum','(exception: '+$!+')');
	end

	begin

		defaultWine,defaultWCMD = getAutoWithParams(nil,false)
		if defaultWine == nil
			defaultWine = '(no wine found)'
		end
		printf(outFormat,'Default flavour',defaultWine)

		if inPath('wine')
			wineVer = getWineVersion()
		else
			wineVer = '(not present)'
		end
		printf(outFormat,'Wine',wineVer)

		cxgBin = getCXwithParams('cxgames',nil,false)
		cxgVer = getCXVersionsFrom(cxgBin,true)

		cxoBin = getCXwithParams('cxoffice',nil,false)
		cxoVer = getCXVersionsFrom(cxoBin,true)

		if(cxoBin && !cxgBin)
			cxgVer = '(not available - aliased to crossover)'
		end

		printf(outFormat,'Crossover Games',cxgVer)
		printf(outFormat,'Crossover',cxoVer)

		cedegaVer = getCedegaVersionString()
		printf(outFormat,'Cedega',cedegaVer)
	rescue => ex
		handleException(ex)
	end
	exit(0)
end

# Purpose: Handle an exception
def handleException(ex)
	puts('---')
	puts('Exception: '+ex.to_s)
	puts('Backtrace: '+"\n"+ex.backtrace.join("\n"))
	puts('---')
	puts()
	puts('An exception has occurred and wwine can not continue.')
	puts('This almost certainly reflects a bug in wwine.')
	puts('Please check that you have the latest version of wwine,')
	puts('and if you do, report this issue along with the text between the "---" above');
	puts('to http://random.zerodogg.org/wwine/bugs')
	exit(1)
end

# Purpose: Get parameters for wine
def getWineWithParams (wine,bottle, missingIsFatal = true)
	final = []
	possibleWines = [ 'wine32','wine','wine64','wine.bin','wine.real' ]
	# Manual search path, in the odd case none of the above are in $PATH.
	# Ie. /usr/lib32/wine/wine.bin is the real wine binary on Debian
	searchPath = [ '/usr/lib32/wine/','/usr/bin' ]
	# If wine is not a path or does not exist, check for wine in the path
	if !File.exists?(wine)
		wine = nil
		possibleWines.each do |w|
			if inPath(w)
				wine = w
				break
			end
		end

		if wine == nil
			searchPath.each do |p|
				possibleWines.each do |w|
					if File.executable?(p+'/'+w) && File.file?(p+'/'+w)
						wine = p+'/'+w
						break
					end
				end
				if wine != nil
					break
				end
			end
		end

		if wine == nil
			if missingIsFatal == true
				puts('"wine" does not appear to be installed')
				exit(1)
			else
				return nil
			end
		end
	end
	final.push(wine)

	# Set WINEPREFIX for bottle support
	if(bottle != nil && bottle.length > 0)
		if ENV.has_key?('WINEPREFIX') && ENV['WINEPREFIX'].length > 0
			warn 'WINEPREFIX= was already set, overriding it.'
		end
		if ! (bottle =~ /^\.?\//)
			bottle = ENV['HOME']+'/.wwinebottles/'+bottle
			if !File.exists?(ENV['HOME']+'/.wwinebottles/')
				vputs(ENV['HOME']+'/.wwinebottles/: does not exist, creating')
				begin
					Dir.mkdir(ENV['HOME']+'/.wwinebottles/')
				rescue SystemCallError
					puts('Failed to create directory "'+ENV['HOME']+'/.wwinebottles/'+": "+$!)
					puts('Unable to continue.')
					exit(1)
				end
			end
		end
		ENV['WINEPREFIX'] = bottle
		vputs('Set WINEPREFIX='+bottle)
	end

	# Default to no debugging output if WINEDEBUG is not set yet
	if ! ENV.has_key?('WINEDEBUG')
		vputs 'Set WINEDEBUG=-all'
		ENV['WINEDEBUG'] = '-all'
	end

	return final
end

# Purpose: Get parameters for crossover
def getCXwithParams (wine,bottle, missingIsFatal = true)
	final = []
	cxdir = nil

    installName = wine
    if wine == 'crossover'
        installName = 'cxoffice'
    end
	mode = wine
	bottleDir = '.'+wine

	# Various crossover install paths
	wines = ['/opt/'+installName, ENV['HOME']+'/'+installName, ENV['HOME']+'/.local/'+installName, ENV['HOME']+'/games/'+installName]

	# If cxpath is set then overwrite the default paths
	if $cxPath != nil
		wines = [ $cxPath+'/'+installName, $cxPath ]
	end

	wines.each do |path|
		if File.exists?(path)
			if ( File.executable?(path+'/bin/cximportbottles') || File.executable?(path+'/bin/crossover') ) and wine != 'cxgames'
                # Perform additional detection of dotDir, as that one tends to change
                dotDir = Dir.glob(path+'/etc/cxoffice*.conf').shift
                if( dotDir != nil && dotDir.sub!(/^.*(cxoffice\d*)\.conf$/,'\1') )
                    mode = 'crossover'
                    cxdir = path
                    bottleDir = '.'+dotDir
                    break
                end
			elsif File.executable?(path+'/bin/cxstart')
				cxdir = path
				break
			end
		end
	end

	# If we're using cxPath, perform some additional detection
	if $cxPath != nil and mode != 'crossover'
		if File.exists?($cxPath+'/etc/'+wine+'.conf')
			cxdir = $cxPath
		else
			cxdir = nil
		end
	end

	# If the dir does not exist, give up
	if not cxdir
		if !missingIsFatal
			return nil
		end
		if $cxPath != nil
			puts('Could not find a directory named "'+wine+'" in '+$cxPath)
			puts('and '+$cxPath+' does not appear to be a '+wine+' install directory')
			if wine == 'cxgames'
				reverse = 'cxoffice'
			else
				reverse = 'cxgames'
			end
			if File.exists?($cxPath+'/'+reverse) || File.exists?($cxPath+'/etc/'+reverse+'.conf')
				puts('The directory looks like a '+reverse+' directory. Maybe you wanted')
				puts('--wine '+reverse+' instead?')
			end
		else
			puts('Failed to locate '+wine)
			puts('You could try to explicitly tell wwine where '+wine+' is installed')
			puts('by supplying --cxinstalldir')
		end
		exit(1)
	end

	final.push(cxdir+'/bin/cxstart')
	if(bottle != nil && bottle.length > 0)
		final.push('--bottle',bottle)
	end
	final.push('--');

	# Create the bottle if it does not exist
	if bottle != nil and ! File.exists?(ENV['HOME']+'/'+bottleDir+'/'+bottle)
		puts 'The bottle '+bottle+' did not exist, creating...'
		runcmd([ cxdir+'/bin/cxbottle', '--bottle',bottle,'--create','--template','winxp'],'system')
		if ! File.exists?(ENV['HOME']+'/'+bottleDir+'/'+bottle)
			puts 'Bottle creation failed.'
			exit 1
		end
	end

	if getBottleDir
		return ENV['HOME']+'/'+bottleDir+'/'+bottle
	else
		return final
	end
end

# Purpose: Get parameters for cedega
def getCedegaWithParams (wine,bottle, missingIsFatal = true)
	final = []

	if not inPath('cedega')
		if missingIsFatal
			puts('cedega does not appear to be installed')
			exit(1)
		else
			return nil
		end
	end

	final.push('cedega','--install')

	# Use wwineFolder as the folder if no bottle was supplied
	if (bottle == nil || bottle.length == 0)
		bottle = 'wwineFolder'
	end
	final.push(bottle)

	return final
end

# Purpose: Detect which wine to use and get parameters for that one
# Returns: type,cmd
def getAutoWithParams (bottle, missingIsFatal = true, returnFlavour = false)
	cmd = getWineWithParams('wine',bottle,false)
	type = 'wine'
	if cmd == nil
		cmd = getCXwithParams('cxgames',bottle,false)
		type = 'cxgames'
	end
	if cmd == nil
		cmd = getCXwithParams('cxoffice',bottle,false)
		type = 'cxoffice'
	end
	if cmd == nil
		cmd = getCedegaWithParams('cedega',bottle,false)
		type = 'cedega'
	end
	if cmd == nil
		if missingIsFatal
			puts 'Failed to detect any wine version at all.'
			exit(1)
		else
			return nil
		end
	else
		return type,cmd
	end
end

# Purpose: Run the wine specified, using the bottle specified and arguments specified
def runWine (wine,bottle,args)
	cmd = nil
	type = nil

	if wine == nil
		type,cmd = getAutoWithParams(bottle)
		wine = type
	else
		# Expand cx*
		if wine == 'cxg'
			wine = 'cxgames'
		elsif wine == 'cxo' || wine == 'cx' || wine == 'cxoffice'
			wine = 'crossover'
		end

		type = wine

		if wine == 'cxgames' || wine == 'cxoffice' || wine == 'crossover'
			cmd = getCXwithParams(wine,bottle,false)
            if wine == 'cxgames' && cmd == nil
                cmd = getCXwithParams('crossover',bottle)
                if cmd != nil
                    puts('Converting --wine cxgames to --wine crossover since cxgames is not installed')
                end
            end
		elsif wine == 'wine' || File.executable?(wine)
			type = 'wine'
			cmd = getWineWithParams(wine,bottle)
		elsif wine == 'cedega'
			cmd = getCedegaWithParams(wine,bottle)
		else
			puts('Unknown --wine: '+wine)
			puts('Must be one of: wine, crossover, cxgames, cedega, or the path to a wine executable')
			exit(1)
		end
	end
	cmd.concat(args)

	# If args is a single parameter, that parameter is --version, and we're not using
	# vanilla wine, then we emulate vanilla wine's --version output. This helps
	# utilities like winetricks when it is running under "wwine --env"
	if args.length == 1 && args[0] == '--version'
		# For CX* we can actually output a useful version number, namely the
		# wine version that CX* release was based on
		if wine == 'cxgames' || wine == 'cxoffice' || wine == 'crossover'
			cxgBin = getCXwithParams(wine,nil,false)
			cxVer, cxwVer = getCXVersionsFrom( cxgBin )
			# CX* wine --versions often contain git revisions and other additional
			# information in the version number, this strips that out.
			cxwVer.sub!(/-.*/,'')
			puts 'wine-'+cxwVer
			exit
		# For cedega we just output an invalid version number in the same syntax
		# as vanilla wine would have done
		elsif wine == 'cedega'
			puts 'wine-0.0.0'
			exit
		end
	end

	# If we're in envMode, then we let setEnvAndExec handle the rest
	if $envMode
		setEnvAndExec(wine,bottle,cmd,args,type)
	# If wrapperPath is set, then we're suppose to generate a wrapper script instead
	# of actually executing it.
	elsif $wrapperPath != nil
		generateWrapper(wine,bottle,$wrapperPath,cmd,args,type)
	else
		runcmd(cmd)
	end
end

opts = GetoptLong.new(
	[ '--help', '-h', GetoptLong::NO_ARGUMENT ],
	[ '--wine', '-w', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--bottle', '-b', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--kill', '-k', GetoptLong::OPTIONAL_ARGUMENT ],
	[ '--drykill', GetoptLong::NO_ARGUMENT ],
	[ '--cxinstalldir','-c',GetoptLong::REQUIRED_ARGUMENT ],
	[ '--version',GetoptLong::NO_ARGUMENT ],
	[ '--wrap', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--wrapdir', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--debuginfo', GetoptLong::NO_ARGUMENT ],
	[ '--man', GetoptLong::NO_ARGUMENT ],
	[ '--env', GetoptLong::NO_ARGUMENT ],
	[ '--tricks', GetoptLong::NO_ARGUMENT ],
	[ '--env-bottle', GetoptLong::NO_ARGUMENT ],
	[ '--from', '-s', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--verbose', '-v', GetoptLong::NO_ARGUMENT ]
)

# Handle command-line arguments
begin
	opts.each do |opt, arg|
		case opt
		when '--help'
			Help()
			exit(0)
		when '--wine'
			$wine = arg
		when '--bottle'
			$bottle = arg
		when '--env-bottle'
			if ENV['WINEPREFIX'] && ENV['WINEPREFIX'].length > 0
				$bottle = File.basename(ENV['WINEPREFIX'])
			else
				puts 'wwine: --env-bottle supplied but WINEPREFIX is not set'
				exit(1)
			end
		when '--verbose'
			$verbose = true
		when '--drykill'
			killWine(true)
			exit(0)
		when '--debuginfo'
			debugInfo()
		when '--kill'
			begin
				killWine(false,arg)
			rescue
				puts "Error while attempting to kill processes: "+$!
			end
			exit(0)
		when '--cxinstalldir'
			$cxPath = arg
		when '--version'
			puts('wwine version '+$version+' (for wine version info, run wwine --debuginfo)')
			exit(0)
		when '--wrap'
			$wrapperPath = arg
		when '--wrapdir'
			$wrapperCwd = arg
		when '--from'
			$wwineDataFrom = arg
		when '--env'
			$envMode = true
		when '--tricks'
			$tricksMode = true
			$envMode = true
		when '--man'
			showManPage()
			exit(0)
		end
	end

	if ENV['WWINE_VERBOSE'] != nil && ENV['WWINE_VERBOSE'] == '1'
		puts('--verbose assumed because the environment variable WWINE_VERBOSE is set to 1')
		$verbose = true
	end
rescue
	puts('See --help for more inforation')
	exit(1)
end

if $wwineDataFrom
	loadWwineDataFromFile($wwineDataFrom)
end

if ARGV.length == 0 && !$envMode
	Help()
	exit(1)
end

if $tricksMode
	ARGV.unshift('winetricks','--no-isolate')
end

begin
	runWine($wine,$bottle,ARGV)
rescue => ex
	handleException(ex)
end
