#!/usr/bin/ruby
# wwine
# Copyright (C) Eskild Hustvedt 2009
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Command-line parsing
require 'getoptlong'
# Application version
$version = 0.1
# The wine flavour to use
$wine = 'wine'
# The bottle to use
$bottle = nil
# Verbose mode (true/false)
$verbose = false
# CX path
$cxPath = nil
# Path to write wrapper to
$wrapperPath = nil
# Directory to cd to in a wrapper
$wrapperCwd = nil

# Purpose: Attempt to kill all running wine processes
def killWine (dryRun = false)
	# Open a pipe to ps to read processes
	wines = IO.popen('ps uxw')
	# True if we have killed something
	killed = false
	# Go through each line in the 'ps' output
	wines.each do |line|
		line.chomp!
		# Ignore the ehader
		if line =~ /USER\s*PID/
			next
		end
		pid = String.new(line)
		name = String.new(line)
		# Parse the PID
		pid.sub!(/^\S+\s*(\d+)\s+.*/,'\1')
		# Parse the name
		name.sub!(/^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+/,'')
		# If either of these are true some part of the parsing failed, and we
		# should thus simply skip this line
		if pid == name || pid == line || name == line
			next
		end
		# Ignore processes that are not wine-related
		if name =~ /(wine|windows|[a-z]:\\|\.(exe|dll))/i
			# If wine is not a part of the process name, check if the
			# name either includes a \ (which most likely means it is a windows
			# path because it has already matched one of the above) or exe/dll.
			if ! name =~ /wine/i && ( name =~ /\// || ! name =~ /\.(exe|dll)/i )
				next
			# Ignore mono and vim
			elsif name =~ /wwine/i || name =~ /(mono|vim)/i
				next
			end
		else
			next
		end
		# Clean up the name
		name.sub!(/\s*$/,'')
		# Send SIGTERM (or output information if in dryRun mode)
		if !dryRun
			puts 'Sending SIGTERM to '+name+' (PID '+pid+')'
			Process.kill(15,pid.to_i)
		else
			puts 'Would send SIGTERM to '+name+' (PID '+pid+')'
		end
		killed = true
	end
	if ! killed
		puts 'No wine processes found.'
	end
end

# Purpose: Print formatted --help output
# Usage: printHelp('-shortoption', '--longoption', 'description');
#  Description will be reformatted to fit within a normal terminal
def printHelp (short,long,description)
	maxlen = 80
	optionlen = 20
	# Check if the short/long are LONGER than optionlen, if so, we need
	# to do some additional magic to take up only $maxlen.
	# The +1 here is because we always add a space between them, no matter what
	if (short.length + long.length + 1) > optionlen
		optionlen = short.length + long.length + 1;
	end

	generatedDesc = ''
	currdesc = ''

	description.split(/ /).each do |part|
		if(generatedDesc.length > 0)
			if (currdesc.length + part.length + 1 + 20) > maxlen
				generatedDesc.concat("\n")
				currdesc = ''
			else
				currdesc.concat(' ')
				generatedDesc.concat(' ')
			end
		end
		currdesc.concat(part)
		generatedDesc.concat(part)
	end
	if !(generatedDesc.length > 0)
		raise("Option mismatch")
	end
	generatedDesc.split(/\n/).each do |descr|
		printf("%-4s %-15s %s\n",short,long,descr)
		short = ''; long = ''
	end
end

# Purpose: Write a wrapper script
def writeWrapper (targetFile, wwineCommand, otherCommand, cwd, wineprefix = nil)
	# Open the file for riting
	begin
		file = File.open(targetFile,'w')
	rescue
		puts('Failed to open "'+targetFile+'" for writing: '+$!)
		exit(1)
	end

	file.puts('#!/bin/sh')
	file.puts('# Script autogenerated by wwine '+$version.to_s+' (http://random.zerodogg.org/wwine)')
	file.puts('# Licensed under the GNU General Public License version 3 or later')
	file.puts('#')
	file.puts('# You should have received a copy of the GNU General Public License')
	file.puts('# along with wwine. If not, see <http://www.gnu.org/licenses/>.')
	file.puts('')
	file.puts("cd '"+cwd+"' || exit 1")
	file.puts('wwine="'+File.expand_path($0)+'"')
	file.puts('if [ ! -x "$wwine" ]; then')
	file.puts("\t"+'wwine="`which wwine 2> /dev/null`"')
	file.puts('fi')
	file.puts('if [ "x$wwine" != "x" ]; then')
	file.puts("\t"+'exec "$wwine"'+" '"+wwineCommand.join("' '")+"'"+' "$@"')
	file.puts('else')
	if wineprefix != nil
		wineprefix.sub!(/'/,'\\')
		file.puts("\t"+'export WINEPREFIX=\''+wineprefix+'\'')
		file.puts("\t"+'export WINEDEBUG="-all"');
	end
	file.puts("\t"+"exec '"+otherCommand.join("' '")+"'"+' "$@"')
	file.puts('fi')
	file.puts('echo "Launch script failed. No wwine found and wine command failed to exec."')
	file.puts('exit 1')

	file.chmod(0755)
	file.close

	puts('Wrote wrapper script to '+targetFile)
end

# Purpose: Prepare to generate a wrapper script
def generateWrapper (wine,bottle,targetFile,wineCommand,args,type = nil)
	wwineCmd = []

	if File.exists?(targetFile)
		puts(targetFile+': already exists. Bailing out')
		puts('Remove the target file first, then try again')
		exit(1)
	end

	# Generate a wwine command-line
	if $verbose
		wwineCmd.push('--verbose')
	end
	if $cxPath
		wwineCmd.push('--cxinstalldir',$cxPath)
	end
	if wine
		wwineCmd.push('--wine',wine)
	end
	if bottle
		wwineCmd.push('--bottle',bottle)
	end
	# Append -- if it isn't already
	if ! args.join(' ').match(/ -- /)
		wwineCmd.push('--')
	end

	wwineCmd.concat(args)

	if $wrapperCwd == nil
		$wrapperCwd = Dir.pwd
	end

	wineprefix = nil

	if type == 'wine'
		wineprefix = ENV['WINEPREFIX']
	end

	writeWrapper(targetFile ,wwineCmd, wineCommand, $wrapperCwd, wineprefix)
end

# Purpose: Run a command, outputting info of it in verbose mode
def runcmd(cmd, type = 'exec')
	vputs 'Running: '+cmd.join(' ')
	if(type == 'exec')
		exec *cmd
	else
		return system(*cmd)
	end
end

# Purpose: Check for a file in path
def inPath(exec)
	ENV['PATH'].split(/:/).each do |part|
		if File.executable?(part+'/'+exec) and not File.directory?(part+'/'+exec)
			return true
		end
	end
	return false
end

# Purpose: Output a string if in verbose mode
def vputs (str)
	if $verbose
		puts(str)
	end
end

# Purpose: Print the help output
def Help ()
	puts "wwine "+$version.to_s
	puts ""
	puts "Usage: wwine (PARAMETERS) PROGRAM -- [ARGUMENTS]"
	puts ""
	printHelp('-h','--help','Display this help text')
	printHelp('-w','--wine','Select the wine to use: wine, cxoffice, cxgames, cedega, or a path to a wine bin. Default: wine')
	printHelp('-b','--bottle','Use the selected bottle (~/.winebottle_[NAME] for wine, CX bottle or cedega folder, depending on the --wine in use). The bottle will be created if it does not exist.')
	printHelp('-k','--kill','Attempt to kill all running wine processes')
	printHelp('','--drykill','Print what --kill would have done, but don\'t actually do anything')
	printHelp('-c','--cxinstalldir','Use the supplied path as the install path for CXoffice/CXgames (default: autodetect).')
	printHelp('','--wrap','Write a wrapper script of your current wwine command to the path supplied')
	printHelp('','--wrapdir','Use the supplied directory as the working directory for the script created by --wrap (default: current directory)')
	printHelp('-v','--verbose','Enable verbose mode')
end

# Purpose: Print debugging info
def debugInfo ()
	puts "wwine "+$version.to_s
	begin
		if inPath('md5sum')
			outStr = nil
			out = IO.popen('md5sum '+File.expand_path($0))
			outStr = out.readline
			outStr.sub!(/\s+.*$/,'')
			puts('md5sum: '+outStr)
		end
	rescue
		puts('(exception while generating md5sum: '+$!+')')
	end
	exit(0)
end

# Purpose: Get parameters for wine
def getWineWithParams (wine,bottle)
	final = []
	# If wine is not a path or does not exist, check for wine in the path
	if !File.exists?(wine)
		if not inPath('wine')
			puts('"wine" appears not to be installed')
			exit(1)
		else
			wine = 'wine'
		end
	end
	final.push(wine)

	# Set WINEPREFIX for bottle support
	if(bottle != nil && bottle.length > 0)
		if ENV.has_key?('WINEPREFIX') && ENV['WINEPREFIX'].length > 0
			warn 'WINEPREFIX= was already set, overriding it.'
		end
		if ! (bottle =~ /^\.?\//)
			bottle = ENV['HOME']+'/.winebottle_'+bottle
		end
		ENV['WINEPREFIX'] = bottle
		vputs('Set WINEPREFIX='+bottle)
	end

	# Default to no debugging output if WINEDEBUG is not set yet
	if ! ENV.has_key?('WINEDEBUG')
		vputs 'Set WINEDEBUG=-all'
		ENV['WINEDEBUG'] = '-all'
	end

	return final
end

# Purpose: Get parameters for crossover
def getCXwithParams (wine,bottle)
	final = []
	cxdir = nil

	# Various crossover install paths
	wines = ['/opt/'+wine, ENV['HOME']+'/'+wine, ENV['HOME']+'/.local/'+wine, ENV['HOME']+'/games/'+wine]

	# If cxpath is set then overwrite the default paths
	if $cxPath != nil
		wines = [ $cxPath+'/'+wine ]
	end

	wines.each do |path|
		if File.exists?(path)
			cxdir = path
			break
		end
	end

	# If we're using cxPath, perform some additional detection
	if $cxPath != nil
		if File.exists?($cxPath+'/etc/'+wine+'.conf')
			cxdir = $cxPath
		end
	end

	# If the dir does not exist, give up
	if not cxdir
		if $cxPath != nil
			puts('Could not find a directory named "'+wine+'" in '+$cxPath)
			puts('and '+$cxPath+' does not appear to be a '+wine+' install directory')
		else
			puts('Failed to locate '+wine)
		end
		exit(1)
	end

	# Find the bin
	bin = cxdir+'/bin/cxstart'
	if not File.executable?(bin)
		puts(wine+': does not appear to be installed in '+cxdir)
		exit(1)
	end
	final.push(cxdir+'/bin/cxstart')
	if(bottle != nil && bottle.length > 0)
		final.push('--bottle',bottle)
	end

	# Create the bottle if it does not exist
	if ! File.exists?(ENV['HOME']+'/.'+wine+'/'+bottle)
		puts 'The bottle '+bottle+' did not exist, creating...'
		runcmd([ cxdir+'/bin/cxbottle', '--bottle',bottle,'--create'],'system')
		if ! File.exists?(ENV['HOME']+'/.'+wine+'/'+bottle)
			puts 'Bottle creation failed.'
			exit 1
		end
	end

	return final
end

# Purpose: Get parameters for cedega
def getCedegaWithParams (wine,bottle)
	final = []

	if not inPath('cedega')
		puts('cedega does not appear to be installed')
		exit(1)
	end

	final.push('cedega','--install')

	# Use wwineFolder as the folder if no bottle was supplied
	if (bottle == nil || bottle.length == 0)
		bottle = 'wwineFolder'
	end
	final.push(bottle)

	return final
end

# Purpose: Run the wine specified, using the bottle specified and arguments specified
def runWine (wine,bottle,args)
	cmd = nil
	# Expand cxg and cxo
	if wine == 'cxg'
		wine = 'cxgames'
	elsif wine == 'cxo'
		wine = 'cxoffice'
	end

	type = wine

	if wine == 'cxgames' || wine == 'cxoffice'
		cmd = getCXwithParams(wine,bottle)
	elsif wine == 'wine' || Flie.executable?(wine)
		type = 'wine'
		cmd = getWineWithParams(wine,bottle)
	elsif wine == 'cedega'
		cmd = getCedegaWithParams(wine,bottle)
	else
		puts('Unknown --wine: '+wine)
		puts('Must be one of: wine, cxgames, cxoffice, cedega, or the path to a wine executable')
		exit(1)
	end
	cmd.concat(args)

	# If wrapperPath is set, then we're suppose to generate a wrapper script instead
	# of actually executing it.
	if $wrapperPath != nil
		generateWrapper(wine,bottle,$wrapperPath,cmd,args,type)
	else
		runcmd(cmd)
	end
end

opts = GetoptLong.new(
	[ '--help', '-h', GetoptLong::NO_ARGUMENT ],
	[ '--wine', '-w', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--bottle', '-b', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--kill', '-k', GetoptLong::NO_ARGUMENT ],
	[ '--drykill', GetoptLong::NO_ARGUMENT ],
	[ '--cxinstalldir','-c',GetoptLong::REQUIRED_ARGUMENT ],
	[ '--version',GetoptLong::NO_ARGUMENT ],
	[ '--wrap', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--wrapdir', GetoptLong::REQUIRED_ARGUMENT ],
	[ '--debuginfo', GetoptLong::NO_ARGUMENT ],
	[ '--verbose', '-v', GetoptLong::NO_ARGUMENT ]
)

# Handle command-line arguments
begin
	opts.each do |opt, arg|
		case opt
		when '--help'
			Help()
			exit(0)
		when '--wine'
			$wine = arg
		when '--bottle'
			$bottle = arg
		when '--verbose'
			$verbose = true
		when '--drykill'
			killWine(true)
			exit(0)
		when '--debuginfo'
			debugInfo()
		when '--kill'
			begin
				killWine()
			rescue
				puts "Error while attempting to kill processes: "+$!
			end
			exit(0)
		when '--cxinstalldir'
			$cxPath = arg
		when '--version'
			puts('wwine version '+$version.to_s)
			exit(0)
		when '--wrap'
			$wrapperPath = arg
		when '--wrapdir'
			$wrapperCwd = arg
		end
	end
rescue
	puts('See --help for more inforation')
	exit(1)
end

if ARGV.length == 0
	Help()
	exit(1)
end

begin
	runWine($wine,$bottle,ARGV)
rescue
	puts('An exception has occurred and wwine can not continue.')
	puts('This almost certainly reflects a bug in wwine.')
	puts('Please check that you have the latest version off wwine,')
	puts('and if you do, report this issue to http://random.zerodogg.org/wwine/bugs')
	puts()
	puts('Exception: '+$!)
	exit(1)
end
